# Define GCN-Based Recommender Model
class GCNRecommender(Model):
    def __init__(self):
        super().__init__()
        self.gcn1 = GCNConv(16, activation="relu")  # First Graph Convolution Layer
        self.gcn2 = GCNConv(1, activation="sigmoid")  # Output Layer (Recommendation Score)


    def call(self, inputs):
        X, A = inputs
        H = self.gcn1([X, A])  # First GCN Layer
        H = self.gcn2([H, A])  # Output GCN Layer
        return H

# Train the Model

model = GCNRecommender()
model.compile(optimizer="adam", loss="binary_crossentropy", metrics=["accuracy"])

# Convert adjacency matrix to Tensor

A_tensor = tf.convert_to_tensor(A.todense(), dtype=tf.float32)

# Train/Test Split

train_mask = np.random.rand(num_nodes) < 0.8  # 80% training, 20% testing
X_train, Y_train = X[train_mask], Y[train_mask]
X_test, Y_test = X[~train_mask], Y[~train_mask]

# Train Model

model.fit([X_train, A_tensor], Y_train, epochs=50, batch_size=1, verbose=1)

# Evaluate Model

test_loss, test_acc = model.evaluate([X_test, A_tensor], Y_test)
print(f"Test Accuracy: {test_acc:.4f}")

# Get Recommendation Scores

predictions = model.predict([X, A_tensor])
print("\nRecommendation Scores:")
for node, idx in node_index.items():
    print(f"{node}: {predictions[idx][0]:.4f}")
